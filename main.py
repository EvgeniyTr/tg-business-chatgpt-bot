import os
import asyncio
import logging
import threading
import json
import httpx
from collections import defaultdict
from concurrent.futures import ThreadPoolExecutor
from tempfile import NamedTemporaryFile
from datetime import datetime, timedelta
import pytz

from telegram import Update
from telegram.ext import (
    ApplicationBuilder,
    MessageHandler,
    filters,
    ContextTypes,
    CommandHandler,
)
from flask import Flask, request, jsonify
import openai

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

app = Flask(__name__)

# –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
MAX_HISTORY = 3
DELAY_MINUTES = 10  # –ó–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É —Å–æ–æ–±—â–µ–Ω–∏—è–º–∏
SYSTEM_PROMPT = """
–¢—ã - —ç—Ç–æ —è, {owner_name}. –û—Ç–≤–µ—á–∞–π –æ—Ç –º–æ–µ–≥–æ –∏–º–µ–Ω–∏, –∏—Å–ø–æ–ª—å–∑—É—è –º–æ–π —Å—Ç–∏–ª—å –æ–±—â–µ–Ω–∏—è.
–û—Å–Ω–æ–≤–Ω—ã–µ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏:
- {owner_style}
- {owner_details}

–í—Å–µ–≥–¥–∞ –ø—Ä–∏–¥–µ—Ä–∂–∏–≤–∞–π—Å—è —ç—Ç–∏—Ö –ø—Ä–∞–≤–∏–ª:
1. –û—Ç–≤–µ—á–∞–π —Ç–æ–ª—å–∫–æ –æ—Ç –º–æ–µ–≥–æ –ª–∏—Ü–∞ —Å –ø–æ–¥–ø–∏—Å—å—é, —è AI –∞—Å–∏—Å—Ç–µ–Ω—Ç
2. –°–æ—Ö—Ä–∞–Ω—è–π –º–æ–π —Å—Ç–∏–ª—å –æ–±—â–µ–Ω–∏—è
3. –ë—É–¥—å –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω—ã–º
"""
AUTO_GENERATION_KEYWORDS = ["—Å–≥–µ–Ω–µ—Ä–∏—Ä—É–π", "–ø–æ–∫–∞–∂–∏", "—Ñ–æ—Ç–æ", "—Ñ–æ—Ç–∫—É", "–∫–∞—Ä—Ç–∏–Ω–∫", "–∏–∑–æ–±—Ä–∞–∂–µ–Ω"]

class BotManager:
    def __init__(self):
        self.loop = None
        self.application = None
        self.executor = ThreadPoolExecutor(max_workers=1)
        self.initialized = threading.Event()
        self.openai_client = None
        self.chat_history = defaultdict(list)
        self.user_timestamps = {}
        self.init_timeout = 120
        
        self.owner_info = {
            "owner_name": "–°–µ—Ä–≥–µ–π",
            "owner_style": "–°–ø–æ–∫–æ–π–Ω—ã–π, –¥—Ä—É–∂–µ–ª—é–±–Ω—ã–π, —É–≤–µ—Ä–µ–Ω–Ω—ã–π –≤ —Å–µ–±–µ, –∏—Å–ø–æ–ª—å–∑—É—é –ª—ë–≥–∫–∏–π —é–º–æ—Ä –∏ —É–º–µ—Å—Ç–Ω—ã–π —Å–∞—Ä–∫–∞–∑–º, –µ—Å–ª–∏ –Ω—É–∂–Ω–æ ‚Äî –º–æ–≥—É –±—ã—Ç—å –ø—Ä—è–º—ã–º.",
            "owner_details": "–ü—Ä–µ–¥–ø–æ—á–∏—Ç–∞—é –≥–æ–≤–æ—Ä–∏—Ç—å –ø–æ –¥–µ–ª—É, –Ω–æ —É–º–µ—é —Ä–∞–∑–≤–∏—Ç—å –º—ã—Å–ª—å. –¶–µ–Ω—é —Å—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –ø–æ–¥—Ö–æ–¥—ã, —á–∞—Å—Ç–æ –ø—Ä–µ–¥–ª–∞–≥–∞—é —Ä–µ—à–µ–Ω–∏—è –∏ –∏–¥—É –Ω–∞ —à–∞–≥ –≤–ø–µ—Ä—ë–¥. –ì–æ—Ç–æ–≤ –¥–µ–ª–∏—Ç—å—Å—è –æ–ø—ã—Ç–æ–º –∏ –≤–æ–≤–ª–µ–∫–∞—Ç—å –¥—Ä—É–≥–∏—Ö –≤ –ø—Ä–æ—Ü–µ—Å—Å, –µ—Å–ª–∏ –≤–∏–∂—É –≤ —ç—Ç–æ–º —Å–º—ã—Å–ª."
        }

    def start(self):
        def run_loop():
            self.loop = asyncio.new_event_loop()
            asyncio.set_event_loop(self.loop)
            try:
                self.loop.run_until_complete(self._initialize())
                self.initialized.set()
                self.loop.run_forever()
            except Exception as e:
                logger.critical(f"–û—à–∏–±–∫–∞: {str(e)}", exc_info=True)
                os._exit(1)

        self.executor.submit(run_loop)

    async def _initialize(self):
        self.openai_client = openai.AsyncOpenAI(
            api_key=os.getenv("OPENAI_API_KEY"),
            base_url=os.getenv("OPENAI_BASE_URL", "https://api.openai.com/v1")
        )
        
        self.application = ApplicationBuilder() \
            .token(os.getenv("TELEGRAM_BOT_TOKEN")) \
            .build()

        # –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤
        self.application.add_handler(MessageHandler(
            self._business_filter(),
            self._handle_business_message
        ))
        self.application.add_handler(CommandHandler("generate_image", self._generate_image))
        self.application.add_handler(MessageHandler(filters.VOICE, self._handle_voice))
        self.application.add_error_handler(self._error_handler)
        
        await self.application.initialize()
        
        if "RENDER" in os.environ:
            await self._setup_webhook()

    def _business_filter(self):
        """–§–∏–ª—å—Ç—Ä –¥–ª—è –±–∏–∑–Ω–µ—Å-—Å–æ–æ–±—â–µ–Ω–∏–π"""
        return filters.TEXT & filters.Lambda(
            lambda msg: bool(getattr(msg, 'business_connection_id', None))
        )

    async def _check_working_hours(self):
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–∞–±–æ—á–µ–≥–æ –≤—Ä–µ–º–µ–Ω–∏ (9:00-18:00 –ø–æ –ú–æ—Å–∫–≤–µ)"""
        tz = pytz.timezone("Europe/Moscow")
        now = datetime.now(tz)
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤—ã—Ö–æ–¥–Ω—ã—Ö
        if now.weekday() >= 5:  # –°—É–±–±–æ—Ç–∞ –∏ –≤–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ
            return False
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–∞–±–æ—á–µ–≥–æ –≤—Ä–µ–º–µ–Ω–∏
        start_time = now.replace(hour=9, minute=0, second=0, microsecond=0)
        end_time = now.replace(hour=18, minute=0, second=0, microsecond=0)
        
        return start_time <= now < end_time

    async def _check_delay(self, user_id: int):
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–¥–µ—Ä–∂–∫–∏ –º–µ–∂–¥—É —Å–æ–æ–±—â–µ–Ω–∏—è–º–∏"""
        last_message = self.user_timestamps.get(user_id)
        if last_message:
            delay = (datetime.now() - last_message).total_seconds() / 60
            if delay < DELAY_MINUTES:
                return False
        self.user_timestamps[user_id] = datetime.now()
        return True

    async def _handle_business_message(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –±–∏–∑–Ω–µ—Å-—Å–æ–æ–±—â–µ–Ω–∏–π"""
        try:
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–∞–±–æ—á–µ–≥–æ –≤—Ä–µ–º–µ–Ω–∏
            if await self._check_working_hours():
                return

            user_id = update.effective_user.id
            
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–¥–µ—Ä–∂–∫–∏
            if not await self._check_delay(user_id):
                return

            # –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ç–µ–∫—Å—Ç–∞
            text = update.message.text.strip()
            response = await self._process_text(user_id, text)
            await update.message.reply_text(response)

        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –±–∏–∑–Ω–µ—Å-—Å–æ–æ–±—â–µ–Ω–∏—è: {str(e)}", exc_info=True)

    async def _generate_image(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –ø–æ –∫–æ–º–∞–Ω–¥–µ"""
        try:
            prompt = ' '.join(context.args)
            response = await self.openai_client.images.generate(
                model="dall-e-3",
                prompt=prompt,
                size="1024x1024",
                quality="standard"
            )
            await update.message.reply_photo(response.data[0].url)
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: {str(e)}")
            await update.message.reply_text("‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ")

    async def _handle_voice(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –≥–æ–ª–æ—Å–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π"""
        try:
            voice_file = await update.message.voice.get_file()
            with NamedTemporaryFile(delete=True, suffix=".ogg") as temp_file:
                await voice_file.download_to_drive(temp_file.name)
                
                transcript = await self.openai_client.audio.transcriptions.create(
                    file=open(temp_file.name, "rb"),
                    model="whisper-1",
                    response_format="text"
                )
                
                if any(kw in transcript.lower() for kw in AUTO_GENERATION_KEYWORDS):
                    await self._generate_image_from_text(update, transcript)
                else:
                    response = await self._process_text(update.effective_user.id, transcript)
                    await update.message.reply_text(f"üé§ –†–∞—Å–ø–æ–∑–Ω–∞–Ω–æ: {transcript}\n\nüìù –û—Ç–≤–µ—Ç: {response}")
                    
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –≥–æ–ª–æ—Å–∞: {str(e)}")
            await update.message.reply_text("‚ö†Ô∏è –û—à–∏–±–∫–∞ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è –≥–æ–ª–æ—Å–∞")

    async def _process_text(self, user_id: int, text: str) -> str:
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ —Ç–µ–∫—Å—Ç–∞ —á–µ—Ä–µ–∑ GPT"""
        messages = [
            {"role": "system", "content": SYSTEM_PROMPT.format(**self.owner_info)},
            *self.chat_history[user_id][-MAX_HISTORY:],
            {"role": "user", "content": text}
        ]
        
        completion = await self.openai_client.chat.completions.create(
            model="gpt-4-turbo-preview",
            messages=messages,
            temperature=0.7
        )
        
        response = completion.choices[0].message.content
        self._update_history(user_id, text, response)
        return response

    def _update_history(self, user_id: int, text: str, response: str):
        """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏—Å—Ç–æ—Ä–∏–∏ —á–∞—Ç–∞"""
        self.chat_history[user_id].extend([
            {"role": "user", "content": text},
            {"role": "assistant", "content": response}
        ])
        if len(self.chat_history[user_id]) > MAX_HISTORY * 2:
            self.chat_history[user_id] = self.chat_history[user_id][-MAX_HISTORY * 2:]

    async def _setup_webhook(self):
        """–ù–∞—Å—Ç—Ä–æ–π–∫–∞ –≤–µ–±—Ö—É–∫–∞"""
        webhook_url = f"{os.getenv('WEBHOOK_URL')}/webhook"
        await self.application.bot.set_webhook(
            url=webhook_url,
            allowed_updates=["message", "business_message", "voice"]
        )
        logger.info(f"–í–µ–±—Ö—É–∫ –Ω–∞—Å—Ç—Ä–æ–µ–Ω: {webhook_url}")

    async def _error_handler(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –æ—à–∏–±–æ–∫"""
        logger.error(f"–ù–µ–æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω–∞—è –æ—à–∏–±–∫–∞: {context.error}", exc_info=True)
        if update and update.message:
            await update.message.reply_text("‚ö†Ô∏è –ü—Ä–æ–∏–∑–æ—à–ª–∞ –≤–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞")

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–æ—Ç–∞
bot_manager = BotManager()
bot_manager.start()

@app.route('/webhook', methods=['POST'])
def webhook():
    try:
        bot_manager.process_update(request.get_json())
        return jsonify({"status": "ok"})
    except Exception as e:
        logger.error(f"Webhook error: {str(e)}")
        return jsonify({"status": "error"}), 500

@app.route('/')
def home():
    return "Telegram Bot is running!"

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)
